using System;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;

namespace ОбластьБуфераСтруктурногоКольцевого
{

    public partial class КлассБуфераСтруктурногоКольцевого
    {
        Int32 ИндексДляЧтенияБуферавБайтах; // в байтах
        Int32 ИндексДляЗаписиБуферавБайтах; // в байтах
        Int32 ИндексДляПропускаФрагментированногоХвостаБуферавБайтах; // Если ИндексДляЧтенияБуфера на него натыкается, то ИндексДляЧтенияБуфера переходит на 0 
        Int32 РазмерБуфераВыровненныйвСловах; // в 32битных Словах
        Int32 РазмерБуфераВыровненныйвБайтах; // в байтах
        Int32[] БуферныйМассив; // в 32битных Словах // начало структур будет выравнено по 32 битам для ускорения копирования.

        Int32[] КакбыБайтРавныйНулю = new Int32[1] { 0 };
        public enum КодыОшибок : Int32
        {
            НетОшибок = 0,
            ПереполнениеБуфера = 1,
            ОшибкаПриРаботесПамятьюиБуферСброшен = 2,
            ОбнаруженаСтруктураНулевойДлины = 4,
            БуферПуст = 8
        }

        public КлассБуфераСтруктурногоКольцевого(Int32 РазмерБуферавБайтах)
        {
            if (РазмерБуферавБайтах < Int32.MaxValue - 5)
                РазмерБуфераВыровненныйвСловах = ((РазмерБуферавБайтах + 3) / 4);
            else
                РазмерБуфераВыровненныйвСловах = ((Int32.MaxValue - 5) / 4);
            БуферныйМассив = new Int32[РазмерБуфераВыровненныйвСловах];
            ИнициализацияСервисныхПеременныхБуфера();
        }

        private void ИнициализацияСервисныхПеременныхБуфера()
        {
            ИндексДляЧтенияБуферавБайтах = 0;
            ИндексДляЗаписиБуферавБайтах = 0;
            РазмерБуфераВыровненныйвБайтах = РазмерБуфераВыровненныйвСловах * 4;
            ИндексДляПропускаФрагментированногоХвостаБуферавБайтах = РазмерБуфераВыровненныйвБайтах;
        }

        public Int32 ПустЛиБуфер() // возращает Int32 равный нулю если пуст.
        {
            return (ИндексДляЧтенияБуферавБайтах - ИндексДляЗаписиБуферавБайтах);
        }


        public Int32 ЗаписатьСтруктурувБуфер(byte[] СтруктураДанных) // возращает Int32 КодОшибки при успехе
        {
            Int32 ДлинаДанных = СтруктураДанных.Length;
            Int32 ДлинаСервиснойИнформацииоДлинеДанных = 4;
            Int32 ДлинаДанныхВыравненнаяПо32Битам = ((ДлинаДанных + 3) / 4); ДлинаДанныхВыравненнаяПо32Битам *= 4;
            Int32 ДлинаПакета = ДлинаДанныхВыравненнаяПо32Битам + ДлинаСервиснойИнформацииоДлинеДанных;
            if (ИндексДляЗаписиБуферавБайтах + ДлинаДанныхВыравненнаяПо32Битам >= РазмерБуфераВыровненныйвБайтах)
            {
                if ((ДлинаДанныхВыравненнаяПо32Битам <= ИндексДляЧтенияБуферавБайтах) // Индекс чтения вне области планируемой записи
                    && (ИндексДляЧтенияБуферавБайтах <= ИндексДляЗаписиБуферавБайтах)) // Индекс чтения вне области пропуска хвостового фрагмента
                {   // Индекс Чтения вне интервала планируемой записи
                    ИндексДляПропускаФрагментированногоХвостаБуферавБайтах = ИндексДляЗаписиБуферавБайтах;
                    return ЗаписатьСтруктурувБуферПоИндексу(СтруктураДанных, 0);
                }
                else
                {
                    return (Int32)КодыОшибок.ПереполнениеБуфера;
                }
            }
            else
            {
                Int32 СледующийПланируемыйИндексДляЗаписиБуферавБайтах = ИндексДляЗаписиБуферавБайтах + ДлинаДанныхВыравненнаяПо32Битам;
                if ((СледующийПланируемыйИндексДляЗаписиБуферавБайтах < ИндексДляЧтенияБуферавБайтах) || // Индекс Чтения точно справа относительно планируемого интервала записи
                    (ИндексДляЗаписиБуферавБайтах >= ИндексДляЧтенияБуферавБайтах)) // Индекс Чтения точно слева относительно планируемого интервала записи
                {   // Индекс Чтения вне интервала планируемой записи
                    return ЗаписатьСтруктурувБуферПоИндексу(СтруктураДанных, ИндексДляЗаписиБуферавБайтах);
                }
                else
                {
                    return (Int32)КодыОшибок.ПереполнениеБуфера;
                }
            }
        }

        private Int32 ЗаписатьСтруктурувБуферПоИндексу(byte[] СтруктураДанных, Int32 ИндексДляНачалаЗаписи)
        {
            Int32 ДлинаДанных = (Int32)СтруктураДанных.Length;
            Int32 ДлинаСервиснойИнформацииоДлинеДанных = 4;
            Int32 ДлинаДанныхВыравненнаяПо32Битам = ((ДлинаДанных + 3) / 4); ДлинаДанныхВыравненнаяПо32Битам *= 4;
            Int32 ДлинаПакета = ДлинаДанныхВыравненнаяПо32Битам + ДлинаСервиснойИнформацииоДлинеДанных;

            Int32[] СервиснаяИнформацияоДлинеДанных = new Int32[1] { ДлинаДанных };

            try
            {
                Buffer.BlockCopy(СервиснаяИнформацияоДлинеДанных, 0,
                                БуферныйМассив, ИндексДляНачалаЗаписи,
                                ДлинаСервиснойИнформацииоДлинеДанных);
                Buffer.BlockCopy(СтруктураДанных, 0,
                    БуферныйМассив, ИндексДляНачалаЗаписи + ДлинаСервиснойИнформацииоДлинеДанных,
                    ДлинаДанных);
                for (Int32 индекс = ДлинаДанных; индекс < ДлинаДанныхВыравненнаяПо32Битам; индекс++) // стирание старой информации во фрагменте, оставшемся из-за выравнивания
                {
                    Buffer.BlockCopy(КакбыБайтРавныйНулю, 0,
                        БуферныйМассив , ИндексДляНачалаЗаписи + ДлинаСервиснойИнформацииоДлинеДанных + индекс,
                        1);
                }
                ИндексДляЗаписиБуферавБайтах = ИндексДляНачалаЗаписи + ДлинаПакета;
            }
            catch
            {
                ИнициализацияСервисныхПеременныхБуфера();
                for (Int32 индекс = 0; индекс < БуферныйМассив.Length; индекс++)
                    БуферныйМассив[индекс] = 0;
                return (Int32)КодыОшибок.ОшибкаПриРаботесПамятьюиБуферСброшен;
            }
            return (Int32)КодыОшибок.НетОшибок;
        }

        public Int32 ЗабратьСтруктуруИзБуфера(out byte[] СтруктураДанных) // возращает Int32 КодОшибки при успехе
        {
            if (ИндексДляЧтенияБуферавБайтах != ИндексДляЗаписиБуферавБайтах)
            {  // Буфер не пуст
                if (ИндексДляЧтенияБуферавБайтах != ИндексДляПропускаФрагментированногоХвостаБуферавБайтах)
                {
                    return (ЗабратьСтруктуруИзБуфераПоТекущемуИндексуЧтения(out СтруктураДанных));
                }
                else
                { // пропуск хвостового фрагмента
                    ИндексДляЧтенияБуферавБайтах = 0;
                    ИндексДляПропускаФрагментированногоХвостаБуферавБайтах = РазмерБуфераВыровненныйвБайтах;
                    return (ЗабратьСтруктуруИзБуфераПоТекущемуИндексуЧтения(out СтруктураДанных));
                }
            }
            else
            { // Буфер пуст
                СтруктураДанных = null;
                return (Int32)КодыОшибок.БуферПуст;
            }
            //return (Int32)КодыОшибок.НетОшибок;
        }

        private Int32 ЗабратьСтруктуруИзБуфераПоТекущемуИндексуЧтения(out byte[] СтруктураДанных)
        {
            Int32[] СервиснаяИнформацияоДлинеДанных = new Int32[1] { 0 };
            Int32 ДлинаСервиснойИнформацииоДлинеДанных = 4;

            Buffer.BlockCopy(БуферныйМассив, ИндексДляЧтенияБуферавБайтах,
                            СервиснаяИнформацияоДлинеДанных, 0,
                            ДлинаСервиснойИнформацииоДлинеДанных);

            Int32 ДлинаДанных = (Int32)СервиснаяИнформацияоДлинеДанных[0];
            if (ДлинаДанных == 0)
            {
                СтруктураДанных = null;
                return (Int32)КодыОшибок.ОбнаруженаСтруктураНулевойДлины;
            }
            Int32 ДлинаДанныхВыравненнаяПо32Битам = ((ДлинаДанных + 3) / 4); ДлинаДанныхВыравненнаяПо32Битам *= 4;

            Int32 ДлинаПакета = ДлинаДанныхВыравненнаяПо32Битам + ДлинаСервиснойИнформацииоДлинеДанных;
            СтруктураДанных = new byte[ДлинаДанных];
            Buffer.BlockCopy(БуферныйМассив, ИндексДляЧтенияБуферавБайтах + ДлинаСервиснойИнформацииоДлинеДанных,
                             СтруктураДанных, 0,
                             ДлинаДанных);
            ИндексДляЧтенияБуферавБайтах = ИндексДляЧтенияБуферавБайтах + ДлинаПакета; // атомарное подтверждение прочтения
            return (Int32)КодыОшибок.НетОшибок;
        }
    }

}